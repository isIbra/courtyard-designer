<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Courtyard Designer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', sans-serif;
    background: #0a0a0a;
    color: #e0e0e0;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  #canvas-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  canvas { display: block; width: 100%; height: 100%; }

  /* Top Bar */
  #topbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 48px;
    background: rgba(15,15,15,0.92);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    padding: 0 16px;
    z-index: 100;
    gap: 12px;
  }

  #topbar .logo {
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 500;
    color: #c8a96e;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .divider { width: 1px; height: 24px; background: rgba(255,255,255,0.1); }

  .view-btn {
    padding: 6px 14px;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 6px;
    background: transparent;
    color: #999;
    font-family: 'DM Sans', sans-serif;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .view-btn:hover { border-color: rgba(200,169,110,0.4); color: #ddd; }
  .view-btn.active { border-color: #c8a96e; color: #c8a96e; background: rgba(200,169,110,0.08); }

  .topbar-info {
    margin-left: auto;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: #666;
  }

  /* Side Panel */
  #sidepanel {
    position: fixed;
    top: 48px;
    right: 0;
    width: 280px;
    height: calc(100% - 48px);
    background: rgba(18,18,18,0.95);
    backdrop-filter: blur(12px);
    border-left: 1px solid rgba(255,255,255,0.06);
    z-index: 99;
    overflow-y: auto;
    transform: translateX(0);
    transition: transform 0.3s ease;
  }

  #sidepanel.hidden { transform: translateX(100%); }

  .panel-section {
    padding: 16px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  .panel-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: #c8a96e;
    margin-bottom: 12px;
  }

  .furniture-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .furniture-item {
    padding: 10px 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    cursor: pointer;
    text-align: center;
    transition: all 0.2s;
    font-size: 12px;
  }

  .furniture-item:hover {
    border-color: rgba(200,169,110,0.4);
    background: rgba(200,169,110,0.05);
  }

  .furniture-item.selected {
    border-color: #c8a96e;
    background: rgba(200,169,110,0.1);
  }

  .furniture-item .icon { font-size: 22px; margin-bottom: 4px; }
  .furniture-item .label { font-size: 11px; color: #999; }

  /* Color swatches */
  .color-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .color-row label {
    font-size: 11px;
    color: #888;
    width: 100%;
    margin-bottom: 2px;
  }

  .swatch {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s;
  }

  .swatch:hover { transform: scale(1.15); }
  .swatch.active { border-color: #fff; box-shadow: 0 0 8px rgba(200,169,110,0.5); }

  /* Controls hint */
  #controls-hint {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(15,15,15,0.9);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    padding: 10px 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: #888;
    z-index: 100;
    display: flex;
    gap: 16px;
    transition: opacity 0.5s;
  }

  #controls-hint kbd {
    background: rgba(255,255,255,0.08);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 10px;
    color: #c8a96e;
  }

  /* Toggle panel button */
  #toggle-panel {
    position: fixed;
    top: 56px;
    right: 8px;
    z-index: 101;
    background: rgba(18,18,18,0.9);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    color: #999;
    padding: 6px 10px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
  }

  #toggle-panel:hover { color: #c8a96e; border-color: rgba(200,169,110,0.4); }

  /* Crosshair for FPS mode */
  #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    z-index: 50;
    pointer-events: none;
    display: none;
  }

  #crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background: rgba(200,169,110,0.6);
  }

  #crosshair::before {
    width: 2px;
    height: 100%;
    left: 50%;
    transform: translateX(-50%);
  }

  #crosshair::after {
    height: 2px;
    width: 100%;
    top: 50%;
    transform: translateY(-50%);
  }

  /* Selected object highlight */
  #selected-info {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(200,169,110,0.15);
    border: 1px solid rgba(200,169,110,0.3);
    border-radius: 8px;
    padding: 8px 16px;
    font-size: 12px;
    color: #c8a96e;
    z-index: 100;
    display: none;
    font-family: 'JetBrains Mono', monospace;
  }

  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
</style>
</head>
<body>

<div id="topbar">
  <span class="logo">Courtyard Designer</span>
  <div class="divider"></div>
  <button class="view-btn active" id="btn-orbit" onclick="setView('orbit')">Orbit</button>
  <button class="view-btn" id="btn-fps" onclick="setView('fps')">Walk</button>
  <button class="view-btn" id="btn-top" onclick="setView('top')">Top</button>
  <div class="divider"></div>
  <button class="view-btn" id="btn-place" onclick="togglePlaceMode()">+ Place</button>
  <span class="topbar-info" id="pos-info">X: 0.0 Y: 0.0</span>
</div>

<button id="toggle-panel" onclick="togglePanel()">â˜°</button>

<div id="sidepanel">
  <div class="panel-section">
    <div class="panel-title">Furniture</div>
    <div class="furniture-grid" id="furniture-grid"></div>
  </div>

  <div class="panel-section">
    <div class="panel-title">Materials</div>
    <div class="color-row">
      <label>Floor</label>
      <div class="swatch" style="background:#a69882" onclick="setMaterial('floor',0xa69882)" data-target="floor"></div>
      <div class="swatch" style="background:#8B7355" onclick="setMaterial('floor',0x8B7355)" data-target="floor"></div>
      <div class="swatch" style="background:#D2C4A8" onclick="setMaterial('floor',0xD2C4A8)" data-target="floor"></div>
      <div class="swatch" style="background:#556B2F" onclick="setMaterial('floor',0x556B2F)" data-target="floor"></div>
      <div class="swatch" style="background:#4a4a4a" onclick="setMaterial('floor',0x4a4a4a)" data-target="floor"></div>
      <div class="swatch" style="background:#C19A6B" onclick="setMaterial('floor',0xC19A6B)" data-target="floor"></div>
    </div>
    <div class="color-row">
      <label>Walls</label>
      <div class="swatch" style="background:#EBE0D0" onclick="setMaterial('walls',0xEBE0D0)" data-target="walls"></div>
      <div class="swatch" style="background:#D4C5A9" onclick="setMaterial('walls',0xD4C5A9)" data-target="walls"></div>
      <div class="swatch" style="background:#F5F0E8" onclick="setMaterial('walls',0xF5F0E8)" data-target="walls"></div>
      <div class="swatch" style="background:#B8A88A" onclick="setMaterial('walls',0xB8A88A)" data-target="walls"></div>
      <div class="swatch" style="background:#8B8178" onclick="setMaterial('walls',0x8B8178)" data-target="walls"></div>
      <div class="swatch" style="background:#FFFFFF" onclick="setMaterial('walls',0xFFFFFF)" data-target="walls"></div>
    </div>
    <div class="color-row">
      <label>Glass Tint</label>
      <div class="swatch" style="background:rgba(170,215,255,0.4)" onclick="setMaterial('glass',0xAAD7FF)" data-target="glass"></div>
      <div class="swatch" style="background:rgba(200,230,200,0.4)" onclick="setMaterial('glass',0xC8E6C8)" data-target="glass"></div>
      <div class="swatch" style="background:rgba(230,230,230,0.4)" onclick="setMaterial('glass',0xE6E6E6)" data-target="glass"></div>
      <div class="swatch" style="background:rgba(255,220,180,0.4)" onclick="setMaterial('glass',0xFFDCB4)" data-target="glass"></div>
    </div>
  </div>

  <div class="panel-section">
    <div class="panel-title">Scene</div>
    <div class="color-row">
      <label>Time of Day</label>
    </div>
    <input type="range" id="sun-slider" min="0" max="100" value="70" style="width:100%;accent-color:#c8a96e" oninput="updateSun(this.value)">
    <div style="display:flex;justify-content:space-between;font-size:10px;color:#666;margin-top:4px">
      <span>Dawn</span><span>Noon</span><span>Dusk</span>
    </div>
  </div>
</div>

<div id="crosshair"></div>
<div id="selected-info"></div>

<div id="controls-hint">
  <span><kbd>WASD</kbd> Move</span>
  <span><kbd>Mouse</kbd> Look</span>
  <span><kbd>Click</kbd> Place/Select</span>
  <span><kbd>R</kbd> Rotate</span>
  <span><kbd>Del</kbd> Remove</span>
  <span><kbd>Tab</kbd> Panel</span>
</div>

<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============ SCENE SETUP ============
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 30, 80);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(-8, 12, -6);
camera.lookAt(3, 0, 5);

// ============ GLOBALS ============
let viewMode = 'orbit';
let placeMode = false;
let selectedFurniture = null;
let ghostMesh = null;
let placedObjects = [];
let selectedObject = null;
let orbitAngle = 0;
let orbitRadius = 18;
let orbitHeight = 12;
let orbitTarget = new THREE.Vector3(3, 0, 5);

// FPS controls
let fpsPitch = 0;
let fpsYaw = Math.PI;
let fpsPos = new THREE.Vector3(3, 1.7, 3);
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let isPointerLocked = false;

// Materials storage
const matGroups = { floor: [], walls: [], glass: [], frame: [] };

// ============ MATERIALS ============
function makeMat(color, rough, opts = {}) {
  const mat = new THREE.MeshStandardMaterial({
    color,
    roughness: rough,
    metalness: opts.metalness || 0,
    transparent: opts.transparent || false,
    opacity: opts.opacity || 1,
    side: opts.side || THREE.FrontSide,
  });
  return mat;
}

const wallMat = makeMat(0xEBE0D0, 0.85);
const floorMat = makeMat(0xa69882, 0.7);
const glassMat = makeMat(0xAAD7FF, 0.02, { transparent: true, opacity: 0.2, side: THREE.DoubleSide });
const glassWallMat = makeMat(0x9CBFD4, 0.05, { transparent: true, opacity: 0.25, side: THREE.DoubleSide });
const frameMat = makeMat(0x333333, 0.3, { metalness: 0.7 });

// ============ COURTYARD BUILDER ============
const WT = 0.25;
const EAST_H = 7.0;
const WEST_H = 2.4;
const GLASS_RISE = 3.0;
const DOOR_W = 1.8;
const DOOR_H = 2.1;
const DOOR_Y_CENTER = 3.2;
const DOOR_Y_BOT = DOOR_Y_CENTER - DOOR_W / 2;
const DOOR_Y_TOP = DOOR_Y_CENTER + DOOR_W / 2;

const P = [
  [0, 0], [0, 7.11], [0.63, 7.11], [0.63, 11.20],
  [5.18, 11.20], [5.18, 3.20], [6.91, 3.20], [6.91, 0]
];

function slopeZ(x) {
  return EAST_H + (x / 6.91) * (GLASS_RISE - EAST_H);
}

function wallSeg(name, x1, z1, x2, z2, yBot, yTop, tdx, tdz, mat, group) {
  // Note: in Three.js, Y is up. Our courtyard Xâ†’X, Y(up)â†’height, Zâ†’courtyard Y
  const geo = new THREE.BufferGeometry();
  const v = [
    x1, yBot, z1,  x2, yBot, z2,  x2+tdx, yBot, z2+tdz,  x1+tdx, yBot, z1+tdz,
    x1, yTop, z1,  x2, yTop, z2,  x2+tdx, yTop, z2+tdz,  x1+tdx, yTop, z1+tdz,
  ];
  const idx = [
    0,1,2, 0,2,3,  4,6,5, 4,7,6,
    0,4,5, 0,5,1,  2,6,7, 2,7,3,
    0,3,7, 0,7,4,  1,5,6, 1,6,2,
  ];
  geo.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
  geo.setIndex(idx);
  geo.computeVertexNormals();
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.name = name;
  scene.add(mesh);
  if (group && matGroups[group]) matGroups[group].push(mesh);
  return mesh;
}

function buildCourtyard() {
  // Floor (L-shape)
  const floorShape = new THREE.Shape();
  floorShape.moveTo(P[0][0], P[0][1]);
  for (let i = 1; i < P.length; i++) floorShape.lineTo(P[i][0], P[i][1]);
  floorShape.closePath();

  const floorGeo = new THREE.ShapeGeometry(floorShape);
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  floor.name = 'Floor';
  scene.add(floor);
  matGroups.floor.push(floor);

  // Walls
  // East lower - below door
  wallSeg('East_Low_A', 0, 0, 0, DOOR_Y_BOT, 0, EAST_H, WT, 0, wallMat, 'walls');
  // East lower - above door
  wallSeg('East_Low_B', 0, DOOR_Y_TOP, 0, 7.11, 0, EAST_H, WT, 0, wallMat, 'walls');
  // Lintel
  wallSeg('East_Lintel', 0, DOOR_Y_BOT, 0, DOOR_Y_TOP, DOOR_H, EAST_H, WT, 0, wallMat, 'walls');
  // Step
  wallSeg('Step_H', 0, 7.11, 0.63, 7.11, 0, EAST_H, 0, -WT, wallMat, 'walls');
  // East upper
  wallSeg('East_Upper', 0.63, 7.11, 0.63, 11.20, 0, EAST_H, -WT, 0, wallMat, 'walls');
  // South
  wallSeg('South_Solid', 0.63, 11.20, 5.18, 11.20, 0, WEST_H, 0, -WT, wallMat, 'walls');
  wallSeg('South_Glass', 0.63, 11.20, 5.18, 11.20, WEST_H, GLASS_RISE, 0, -WT, glassWallMat, 'glass');
  // West upper
  wallSeg('West_Up_Solid', 5.18, 3.20, 5.18, 11.20, 0, WEST_H, -WT, 0, wallMat, 'walls');
  wallSeg('West_Up_Glass', 5.18, 3.20, 5.18, 11.20, WEST_H, GLASS_RISE, -WT, 0, glassWallMat, 'glass');
  // Bump
  wallSeg('Bump_Top_S', 5.18, 3.20, 6.91, 3.20, 0, WEST_H, 0, -WT, wallMat, 'walls');
  wallSeg('Bump_Top_G', 5.18, 3.20, 6.91, 3.20, WEST_H, GLASS_RISE, 0, -WT, glassWallMat, 'glass');
  wallSeg('Bump_R_S', 6.91, 0, 6.91, 3.20, 0, WEST_H, -WT, 0, wallMat, 'walls');
  wallSeg('Bump_R_G', 6.91, 0, 6.91, 3.20, WEST_H, GLASS_RISE, -WT, 0, glassWallMat, 'glass');
  // North
  wallSeg('North_Solid', 0, 0, 6.91, 0, 0, WEST_H, 0, WT, wallMat, 'walls');
  wallSeg('North_Glass', 0, 0, 6.91, 0, WEST_H, GLASS_RISE, 0, WT, glassWallMat, 'glass');

  // Sloped skylight panels
  buildSkylight();
  buildSteelFrame();
  buildTriangles();
}

function buildSkylight() {
  const panels = [
    { verts: [[0.63-WT,7.11],[5.18-WT,7.11],[5.18-WT,11.20-WT],[0.63-WT,11.20-WT]] },
    { verts: [[WT,3.20],[5.18-WT,3.20],[5.18-WT,7.11],[WT,7.11]] },
    { verts: [[WT,WT],[6.91-WT,WT],[6.91-WT,3.20],[WT,3.20]] },
  ];

  panels.forEach((p, idx) => {
    const geo = new THREE.BufferGeometry();
    const v = [];
    p.verts.forEach(([x, z]) => { v.push(x, slopeZ(x), z); });
    geo.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
    geo.setIndex([0,1,2, 0,2,3]);
    geo.computeVertexNormals();
    const mesh = new THREE.Mesh(geo, glassMat);
    mesh.name = 'Skylight_' + idx;
    scene.add(mesh);
    matGroups.glass.push(mesh);
  });
}

function buildTriangles() {
  // South triangle
  const sGeo = new THREE.BufferGeometry();
  sGeo.setAttribute('position', new THREE.Float32BufferAttribute([
    0.63, GLASS_RISE, 11.20,  5.18, GLASS_RISE, 11.20,  0.63, slopeZ(0.63), 11.20
  ], 3));
  sGeo.setIndex([0,1,2]);
  sGeo.computeVertexNormals();
  const sMesh = new THREE.Mesh(sGeo, glassWallMat);
  sMesh.material.side = THREE.DoubleSide;
  scene.add(sMesh);
  matGroups.glass.push(sMesh);

  // North triangle
  const nGeo = new THREE.BufferGeometry();
  nGeo.setAttribute('position', new THREE.Float32BufferAttribute([
    0, GLASS_RISE, 0,  6.91, GLASS_RISE, 0,  0, slopeZ(0), 0
  ], 3));
  nGeo.setIndex([0,1,2]);
  nGeo.computeVertexNormals();
  const nMesh = new THREE.Mesh(nGeo, glassWallMat);
  nMesh.material.side = THREE.DoubleSide;
  scene.add(nMesh);
  matGroups.glass.push(nMesh);
}

function buildSteelFrame() {
  const bw = 0.04, bh = 0.06;

  // Lateral beams
  const beamYs = [];
  for (let i = 1; i < 12; i++) beamYs.push(i * 11.20 / 12);

  beamYs.forEach((z, i) => {
    let xE, xW;
    if (z < 3.20) { xE = WT; xW = 6.91 - WT; }
    else if (z < 7.11) { xE = WT; xW = 5.18 - WT; }
    else { xE = 0.63 - WT; xW = 5.18 - WT; }

    const zE = slopeZ(xE), zW = slopeZ(xW);
    const geo = new THREE.BufferGeometry();
    const v = [
      xE, zE, z-bw/2,  xW, zW, z-bw/2,  xW, zW, z+bw/2,  xE, zE, z+bw/2,
      xE, zE+bh, z-bw/2,  xW, zW+bh, z-bw/2,  xW, zW+bh, z+bw/2,  xE, zE+bh, z+bw/2,
    ];
    geo.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
    geo.setIndex([0,1,2,0,2,3, 4,6,5,4,7,6, 0,4,5,0,5,1, 2,6,7,2,7,3, 0,3,7,0,7,4, 1,5,6,1,6,2]);
    geo.computeVertexNormals();
    const mesh = new THREE.Mesh(geo, frameMat);
    mesh.name = 'FX_' + i;
    scene.add(mesh);
    matGroups.frame.push(mesh);
  });

  // Longitudinal beams
  [1, 2, 3, 4, 5, 6].forEach((x, i) => {
    const z0 = slopeZ(x);
    let yS = WT, yE = 11.20 - WT;
    if (x >= 5.18 && x < 6.91) { yE = 3.20; }
    else if (x >= 6.91) return;

    const geo = new THREE.BufferGeometry();
    const v = [
      x-bw/2, z0, yS,  x+bw/2, z0, yS,  x+bw/2, z0, yE,  x-bw/2, z0, yE,
      x-bw/2, z0+bh, yS,  x+bw/2, z0+bh, yS,  x+bw/2, z0+bh, yE,  x-bw/2, z0+bh, yE,
    ];
    geo.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
    geo.setIndex([0,1,2,0,2,3, 4,6,5,4,7,6, 0,4,5,0,5,1, 2,6,7,2,7,3, 0,3,7,0,7,4, 1,5,6,1,6,2]);
    geo.computeVertexNormals();
    const mesh = new THREE.Mesh(geo, frameMat);
    mesh.name = 'FY_' + i;
    scene.add(mesh);
    matGroups.frame.push(mesh);
  });
}

// ============ GROUND PLANE ============
function buildGround() {
  const groundGeo = new THREE.PlaneGeometry(100, 100);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a5a3a, roughness: 1 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.05;
  ground.receiveShadow = true;
  ground.name = 'Ground';
  scene.add(ground);
}

// ============ LIGHTING ============
let sunLight;

function buildLights() {
  const amb = new THREE.AmbientLight(0xffeedd, 0.4);
  scene.add(amb);

  sunLight = new THREE.DirectionalLight(0xfff5e6, 2.5);
  sunLight.position.set(5, 15, 8);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.left = -15;
  sunLight.shadow.camera.right = 15;
  sunLight.shadow.camera.top = 15;
  sunLight.shadow.camera.bottom = -15;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 40;
  sunLight.shadow.bias = -0.001;
  scene.add(sunLight);

  const hemi = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.6);
  scene.add(hemi);
}

function updateSun(val) {
  const t = val / 100;
  const angle = t * Math.PI;
  const x = Math.cos(angle) * 15;
  const y = Math.sin(angle) * 15 + 2;
  sunLight.position.set(x, Math.max(y, 1), 8);

  const warmth = t < 0.5 ? t * 2 : (1 - t) * 2;
  const r = 1;
  const g = 0.85 + warmth * 0.15;
  const b = 0.7 + warmth * 0.2;
  sunLight.color.setRGB(r, g, b);
  sunLight.intensity = 1 + Math.sin(angle) * 2;

  const skyR = 0.3 + Math.sin(angle) * 0.25;
  const skyG = 0.5 + Math.sin(angle) * 0.3;
  const skyB = 0.7 + Math.sin(angle) * 0.15;
  scene.background.setRGB(skyR, skyG, skyB);
  scene.fog.color.setRGB(skyR, skyG, skyB);
}

// ============ FURNITURE ============
const furnitureTypes = [
  { id: 'sofa', icon: 'ðŸ›‹ï¸', label: 'Sofa', w: 2.2, h: 0.85, d: 0.9, color: 0x8B7355 },
  { id: 'chair', icon: 'ðŸª‘', label: 'Chair', w: 0.6, h: 0.9, d: 0.6, color: 0x6B4226 },
  { id: 'table', icon: 'ðŸªµ', label: 'Table', w: 1.4, h: 0.75, d: 0.8, color: 0xA0845C },
  { id: 'plant', icon: 'ðŸŒ¿', label: 'Plant', w: 0.5, h: 1.2, d: 0.5, color: 0x3A5F0B },
  { id: 'lamp', icon: 'ðŸ’¡', label: 'Lamp', w: 0.3, h: 1.6, d: 0.3, color: 0xD4A860 },
  { id: 'rug', icon: 'ðŸŸ«', label: 'Rug', w: 2.5, h: 0.02, d: 1.8, color: 0x9B7653 },
  { id: 'shelf', icon: 'ðŸ“š', label: 'Shelf', w: 1.2, h: 1.8, d: 0.35, color: 0x5C4033 },
  { id: 'bed', icon: 'ðŸ›ï¸', label: 'Bed', w: 2.0, h: 0.55, d: 1.6, color: 0xE8DCC8 },
  { id: 'desk', icon: 'ðŸ–¥ï¸', label: 'Desk', w: 1.4, h: 0.75, d: 0.7, color: 0x8B7355 },
  { id: 'ottoman', icon: 'ðŸŸ¤', label: 'Ottoman', w: 0.7, h: 0.45, d: 0.7, color: 0xA0845C },
];

function buildFurniturePanel() {
  const grid = document.getElementById('furniture-grid');
  furnitureTypes.forEach(f => {
    const div = document.createElement('div');
    div.className = 'furniture-item';
    div.innerHTML = `<div class="icon">${f.icon}</div><div class="label">${f.label}</div>`;
    div.onclick = () => selectFurniture(f.id);
    div.dataset.id = f.id;
    grid.appendChild(div);
  });
}

function createFurnitureMesh(type, isGhost = false) {
  const f = furnitureTypes.find(t => t.id === type);
  if (!f) return null;

  let group = new THREE.Group();
  const mat = isGhost
    ? new THREE.MeshStandardMaterial({ color: f.color, transparent: true, opacity: 0.4 })
    : new THREE.MeshStandardMaterial({ color: f.color, roughness: 0.6 });

  if (f.id === 'sofa') {
    // Seat
    const seat = new THREE.Mesh(new THREE.BoxGeometry(f.w, 0.35, f.d), mat);
    seat.position.y = 0.25;
    group.add(seat);
    // Back
    const back = new THREE.Mesh(new THREE.BoxGeometry(f.w, 0.5, 0.15), mat);
    back.position.set(0, 0.55, -f.d/2 + 0.075);
    group.add(back);
    // Arms
    const armMat = isGhost ? mat : new THREE.MeshStandardMaterial({ color: f.color - 0x111111, roughness: 0.6 });
    [-1, 1].forEach(side => {
      const arm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.35, f.d), armMat);
      arm.position.set(side * (f.w/2 - 0.06), 0.42, 0);
      group.add(arm);
    });
  } else if (f.id === 'chair') {
    const seat = new THREE.Mesh(new THREE.BoxGeometry(f.w, 0.05, f.d), mat);
    seat.position.y = 0.45;
    group.add(seat);
    const back = new THREE.Mesh(new THREE.BoxGeometry(f.w, 0.45, 0.05), mat);
    back.position.set(0, 0.7, -f.d/2 + 0.025);
    group.add(back);
    [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx,sz]) => {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.45), mat);
      leg.position.set(sx*(f.w/2-0.05), 0.225, sz*(f.d/2-0.05));
      group.add(leg);
    });
  } else if (f.id === 'table') {
    const top = new THREE.Mesh(new THREE.BoxGeometry(f.w, 0.05, f.d), mat);
    top.position.y = f.h - 0.025;
    group.add(top);
    [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx,sz]) => {
      const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, f.h - 0.05), mat);
      leg.position.set(sx*(f.w/2-0.06), (f.h-0.05)/2, sz*(f.d/2-0.06));
      group.add(leg);
    });
  } else if (f.id === 'plant') {
    // Pot
    const potMat = isGhost ? mat : new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
    const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.14, 0.3), potMat);
    pot.position.y = 0.15;
    group.add(pot);
    // Foliage
    const leafMat = isGhost ? mat : new THREE.MeshStandardMaterial({ color: 0x2D5A1E, roughness: 0.9 });
    const foliage = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), leafMat);
    foliage.position.y = 0.65;
    foliage.scale.y = 1.4;
    group.add(foliage);
  } else if (f.id === 'lamp') {
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.3), mat);
    pole.position.y = 0.65;
    group.add(pole);
    const shadeMat = isGhost ? mat : new THREE.MeshStandardMaterial({ color: 0xFFF8DC, roughness: 0.5, transparent: true, opacity: 0.8 });
    const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 0.25), shadeMat);
    shade.position.y = 1.45;
    group.add(shade);
    if (!isGhost) {
      const light = new THREE.PointLight(0xFFE4B5, 0.8, 5);
      light.position.y = 1.4;
      group.add(light);
    }
  } else if (f.id === 'rug') {
    const rug = new THREE.Mesh(new THREE.BoxGeometry(f.w, f.h, f.d), mat);
    rug.position.y = f.h / 2 + 0.01;
    group.add(rug);
  } else {
    // Generic box for others
    const box = new THREE.Mesh(new THREE.BoxGeometry(f.w, f.h, f.d), mat);
    box.position.y = f.h / 2;
    group.add(box);
  }

  group.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
  group.userData = { type: f.id, furnitureData: f };
  return group;
}

function selectFurniture(id) {
  document.querySelectorAll('.furniture-item').forEach(el => el.classList.remove('selected'));
  const el = document.querySelector(`.furniture-item[data-id="${id}"]`);
  if (el) el.classList.add('selected');

  selectedFurniture = id;
  placeMode = true;
  document.getElementById('btn-place').classList.add('active');

  if (ghostMesh) scene.remove(ghostMesh);
  ghostMesh = createFurnitureMesh(id, true);
  ghostMesh.visible = false;
  scene.add(ghostMesh);
}

// ============ RAYCASTING ============
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function getFloorIntersect(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
  const pt = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, pt);
  return pt;
}

// ============ VIEW MODES ============
function setView(mode) {
  document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-' + mode).classList.add('active');
  viewMode = mode;

  document.getElementById('crosshair').style.display = mode === 'fps' ? 'block' : 'none';

  if (mode === 'fps') {
    fpsPos.set(3, 1.7, 3);
  } else if (mode === 'top') {
    camera.position.set(3.5, 20, 5.6);
    camera.lookAt(3.5, 0, 5.6);
    camera.up.set(0, 0, -1);
  } else {
    camera.up.set(0, 1, 0);
  }

  if (isPointerLocked && mode !== 'fps') {
    document.exitPointerLock();
  }
}

function togglePlaceMode() {
  placeMode = !placeMode;
  document.getElementById('btn-place').classList.toggle('active', placeMode);
  if (!placeMode && ghostMesh) {
    ghostMesh.visible = false;
    selectedFurniture = null;
    document.querySelectorAll('.furniture-item').forEach(el => el.classList.remove('selected'));
  }
}

function togglePanel() {
  document.getElementById('sidepanel').classList.toggle('hidden');
}

// ============ MATERIAL PICKER ============
function setMaterial(group, color) {
  document.querySelectorAll(`.swatch[data-target="${group}"]`).forEach(s => s.classList.remove('active'));
  event.target.classList.add('active');

  if (matGroups[group]) {
    matGroups[group].forEach(mesh => {
      if (mesh.material) mesh.material.color.setHex(color);
    });
  }
}

// ============ INPUT HANDLING ============
renderer.domElement.addEventListener('click', (e) => {
  if (viewMode === 'fps' && !isPointerLocked) {
    renderer.domElement.requestPointerLock();
    return;
  }

  if (placeMode && selectedFurniture) {
    const pt = getFloorIntersect(e);
    if (pt) {
      const obj = createFurnitureMesh(selectedFurniture);
      obj.position.copy(pt);
      scene.add(obj);
      placedObjects.push(obj);
    }
    return;
  }

  // Selection
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(placedObjects.flatMap(o => o.children), true);
  if (hits.length > 0) {
    let obj = hits[0].object;
    while (obj.parent && !obj.userData.type) obj = obj.parent;
    if (obj.userData.type) {
      selectedObject = obj;
      document.getElementById('selected-info').style.display = 'block';
      document.getElementById('selected-info').textContent =
        `Selected: ${obj.userData.type} | R=rotate | Del=remove`;
    }
  } else {
    selectedObject = null;
    document.getElementById('selected-info').style.display = 'none';
  }
});

renderer.domElement.addEventListener('mousemove', (e) => {
  if (viewMode === 'fps' && isPointerLocked) {
    fpsYaw -= e.movementX * 0.002;
    fpsPitch -= e.movementY * 0.002;
    fpsPitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, fpsPitch));
    return;
  }

  if (viewMode === 'orbit' && e.buttons === 1 && !placeMode) {
    orbitAngle += e.movementX * 0.005;
    orbitHeight = Math.max(2, Math.min(25, orbitHeight - e.movementY * 0.05));
  }

  if (placeMode && ghostMesh) {
    const pt = getFloorIntersect(e);
    if (pt) {
      ghostMesh.position.copy(pt);
      ghostMesh.visible = true;
    }
  }

  const pt = getFloorIntersect(e);
  if (pt) {
    document.getElementById('pos-info').textContent = `X: ${pt.x.toFixed(1)} Z: ${pt.z.toFixed(1)}`;
  }
});

renderer.domElement.addEventListener('wheel', (e) => {
  if (viewMode === 'orbit') {
    orbitRadius = Math.max(5, Math.min(35, orbitRadius + e.deltaY * 0.01));
  } else if (viewMode === 'top') {
    camera.position.y = Math.max(5, Math.min(40, camera.position.y + e.deltaY * 0.01));
  }
});

document.addEventListener('pointerlockchange', () => {
  isPointerLocked = document.pointerLockElement === renderer.domElement;
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Tab') { e.preventDefault(); togglePanel(); }
  if (e.key === 'w' || e.key === 'W') moveForward = true;
  if (e.key === 's' || e.key === 'S') moveBackward = true;
  if (e.key === 'a' || e.key === 'A') moveLeft = true;
  if (e.key === 'd' || e.key === 'D') moveRight = true;
  if (e.key === 'r' || e.key === 'R') {
    if (selectedObject) selectedObject.rotation.y += Math.PI / 4;
    if (ghostMesh) ghostMesh.rotation.y += Math.PI / 4;
  }
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedObject) {
      scene.remove(selectedObject);
      placedObjects = placedObjects.filter(o => o !== selectedObject);
      selectedObject = null;
      document.getElementById('selected-info').style.display = 'none';
    }
  }
  if (e.key === 'Escape') {
    placeMode = false;
    selectedFurniture = null;
    if (ghostMesh) ghostMesh.visible = false;
    document.getElementById('btn-place').classList.remove('active');
    document.querySelectorAll('.furniture-item').forEach(el => el.classList.remove('selected'));
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'w' || e.key === 'W') moveForward = false;
  if (e.key === 's' || e.key === 'S') moveBackward = false;
  if (e.key === 'a' || e.key === 'A') moveLeft = false;
  if (e.key === 'd' || e.key === 'D') moveRight = false;
});

// ============ ANIMATION LOOP ============
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const speed = 4;

  if (viewMode === 'fps') {
    const dir = new THREE.Vector3();
    if (moveForward) dir.z -= 1;
    if (moveBackward) dir.z += 1;
    if (moveLeft) dir.x -= 1;
    if (moveRight) dir.x += 1;
    dir.normalize();

    const euler = new THREE.Euler(0, fpsYaw, 0, 'YXZ');
    dir.applyEuler(euler);
    fpsPos.add(dir.multiplyScalar(speed * dt));

    camera.position.copy(fpsPos);
    const lookDir = new THREE.Vector3(
      Math.sin(fpsYaw) * Math.cos(fpsPitch),
      Math.sin(fpsPitch),
      -Math.cos(fpsYaw) * Math.cos(fpsPitch)
    );
    camera.lookAt(camera.position.clone().add(lookDir));
    camera.up.set(0, 1, 0);
  } else if (viewMode === 'orbit') {
    camera.position.x = orbitTarget.x + Math.sin(orbitAngle) * orbitRadius;
    camera.position.z = orbitTarget.z + Math.cos(orbitAngle) * orbitRadius;
    camera.position.y = orbitHeight;
    camera.lookAt(orbitTarget);
  }

  renderer.render(scene, camera);
}

// ============ RESIZE ============
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============ INIT ============
buildLights();
buildGround();
buildCourtyard();
buildFurniturePanel();
updateSun(70);
animate();

// Hide controls hint after 8 seconds
setTimeout(() => {
  document.getElementById('controls-hint').style.opacity = '0';
  setTimeout(() => document.getElementById('controls-hint').style.display = 'none', 500);
}, 8000);
</script>
</body>
</html>
